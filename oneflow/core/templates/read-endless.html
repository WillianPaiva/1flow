{% extends 'home.html' %}
{% load endless %}

{% block title %}{% trans 'Read' %}{% endblock title %}
{% block body_id %}read{% endblock body_id %}

{% block application_content %}
{% with home_style=preferences.home.style %}
<div class="row-fluid">
    <div id="reads-number" class="span8 offset2">
        <h2><small>
            {% blocktrans count reads_count as reads %}
                <span id="reads_count">{{ reads }}</span> article
            {% plural %}
                <span id="reads_count">{{ reads }}</span> articles
            {% endblocktrans %}
        </small></h2>
    </div>
    <!--
    <div class="span1">
        <div class="btn-toolbar pull-right">
            <div class="btn-group" data-toggle="buttons-radio">
                <button class="btn preference {% if home_style == 'RL' %}active{% endif %}"
                    data-preference-url="{% url 'set_preference' base='home' sub='style' value='RL' %}"
                    data-preference-value="RL"
                    title=""><i class="icon-list"></i></button>

                <button class="btn preference {% if home_style == 'TL' %}active{% endif %}"
                    data-preference-url="{% url 'set_preference' base='home' sub='style' value='TL' %}"
                    data-preference-value="TL"
                    title=""><i class="icon-th-large"></i></button>

            {% if user.is_superuser %}
                <button class="btn btn-warning preference {% if home_style == 'T1' %}active{% endif %}"
                    data-preference-url="{% url 'set_preference' base='home' sub='style' value='T1' %}"
                    data-preference-value="T1"
                    title="{% trans "Experimental tiles #1" %}"><i class="icon-th"></i></button>

            {% endif %}
            </div>
        </div>
    </div>
    -->
</div>
<div class="row-fluid">
    {% if reads %}
        {% with items_per_fetch=config.READ_INFINITE_ITEMS_PER_FETCH %}

            {% lazy_paginate items_per_fetch reads %}

            {% if preferences.home.style == 'RL' %}
                <ul id="reads-container" class="media-list span8 offset2">
                    {% with read_item_template='snippets/read/read-list-row.html' %}
                        {% include 'snippets/read/read-endless-page.html' %}
                    {% endwith %}
                </ul>

            {% elif preferences.home.style == 'T1' %}
                <div id="reads-container" class="span8 offset2">
                    {% with read_item_template='snippets/read/read-tiles-experimental-tile.html' %}
                        {% include 'snippets/read/read-endless-page.html' %}
                    {% endwith %}
                </div>

            {% else %}
                {# by default, with no preference, we use the TILING mode #}

                <div id="reads-container" class="span8 offset2">
                    {% with read_item_template='snippets/read/read-tiles-tile.html' %}
                        {% include 'snippets/read/read-endless-page.html' %}
                    {% endwith %}
                </div>
            {% endif %}

            {% show_more _('Load more entries') _('Loading…') %}

        {% endwith %}

    {% else %}
        <div class="hero-unit span8 offset2">
            <h2>{% trans "Nothing to read yet. Buy a book?" %}</h2>
        </div>

    {% endif %}
</div>
{% endwith %}
{% endblock application_content %}

{% block extrajs_footer %}
    {{ block.super }}
    {% compressed_js 'read-endless' %}

    <script type="text/javascript">

        {% include "snippets/read/actions-messages.js" %}

    function endless_load_next_if_needed() {

        {% comment %}
            When there are un-processed articles, they are skipped and not
            displayed. In that particular case, the reading list page can
            appear nearly empty if there are a lot of them. We compensate
            by fetching one or two more to fill the user view.

            We do this only for the first set of pages, to avoid the fuss
            of selecting and couting a large set of items when the user
            has already scrolled a lot.

            As a side node, the farther he scrolls, the less non-processed
            articles he will encounter, because he gets back in the past.
        {% endcomment %}

        next_page = parseInt($('.endless_more').attr('href').split('=')[1]);
        //console.log('next_page: ' + next_page);

        if (next_page <= 5) {
            if ($(".read-list-item").length
                    < {{ config.READ_INFINITE_ITEMS_PER_FETCH }}) {
                console.debug('fetching next page to fill the view…');
                $('.endless_container').find('a.endless_more').click();
            }
        }
    }

    function endless_new_page_load_completed(context, fragment) {
        // console.log('Label:', $(this).text());
        //console.log('URL:', context.url);
        //console.log('Querystring key:', context.key);
        // console.log('Fragment:', fragment);

        $('body').find('.endless_container').remove();

        var new_items   = $(fragment);
        var new_endless = new_items.find('.endless_container');

        // NOTE: .after() moved the new_endless.
        // No need to remove it from the fragment.

        reads_container
            .after(new_endless)
            .append(new_items)
        {% if preferences.home.style|slice:'1' == 'T' %}
            .isotope('appended', new_items);
        {% else %}
            ;
        {% endif %}

        setup_everything(new_items);

        console.debug('Finished loading ', context.url);

        endless_load_next_if_needed();

        // We return false to avoid
        // endless normal processing.
        return false;
    }

    var reads_container = $('#reads-container');

    {% if preferences.home.style|slice:'1' == 'T' %}

        reads_container.isotope({
          itemSelector: '.read-list-item'
        });

    {% endif %}

    $.endlessPaginate({

        {% if config.READ_INFINITE_AUTOSCROLL_ENABLED %}
            paginateOnScroll: true,
            paginateOnScrollMargin: 1500,

        {% endif %}

        onCompleted: endless_new_page_load_completed
    });

    endless_load_next_if_needed();

        {% if user.is_superuser %}

        Mousetrap.bind('> >', function() {
            on_hovered(function(current) {
                var admin_informations = current.find('.admin-informations');
                admin_informations.slideToggle(function() {
                    if (admin_informations.is(':visible')) {
                        scrollToElement(admin_informations.attr('id'));
                    }
                });
            });
        });
        {% endif %}

        // “Next”, “Goto Next”, “Open Next”
        Mousetrap.bind(['n', 'g n', 'o n'], function() {
            open_next_read();
            return false;
        });

        // “Mark Read” + “Next”, “Goto Next”, “Open Next”
        Mousetrap.bind(['shift+n',
                        'g shift+n', 'shift+g shift+n',
                        'o shift+n', 'shift+o shift+n'], function() {
            mark_current_read_is_read();
            open_next_read();
            return false;
        });

        // “Previous”, “Goto Previous”, “Open Previous”
        Mousetrap.bind(['p', 'g p', 'o p'], function() {
            open_previous_read();
            return false;
        });

        // “Mark Read” + “Next”, “Goto Next”, “Open Next”
        Mousetrap.bind(['shift+p',
                        'g shift+p', 'shift+g shift+p',
                        'o shift+p', 'shift+o shift+p'], function() {
            mark_current_read_is_read();
            open_previous_read();
            return false;
        });

        function mark_current_read_is_read() {
            if (open_content) {
                var read = $("#" + open_content);

                if (!read.hasClass('is_read')) {
                    return mark_something(open_content, 'is_read', true,
                                          '<no_notification>', false);
                }
            }
        }

        function mark_current_read_is_starred() {
            if (open_content) {
                var read = $("#" + open_content);

                if (!read.hasClass('is_starred')) {
                    return mark_something(open_content, 'is_starred', true,
                                          '<no_notification>', false);
                }
            }
        }

        function mark_current_read_is_bookmarked() {
            if (open_content) {
                var read = $("#" + open_content);

                if (!read.hasClass('is_bookmarked')) {
                    return mark_something(open_content, 'is_bookmarked', true,
                                          '<no_notification>', false);
                }
            }
        }

        function toggle_current_read_is_read() {

            if (open_content) {
                return toggle_is_read(open_content, {
                    done: "{% trans 'Marked read.' %}",
                    undone: "{% trans 'Marked unread.' %}"
                });

            } else {
                notify({
                    text: "{% trans 'Nothing open to mark as read/unread' %}",
                    type: 'warning',
                    icon: false,
                    sticker: false
                });
            }
        }

        function toggle_current_read_is_starred() {

            if (open_content) {
                return toggle_is_starred(open_content, {
                    done: "{% trans 'Oh my GOD! it shines!! [like a star]' %}",
                    undone: "{% trans 'A star is dead.' %}"
                });

            } else {
                notify({
                    text: "{% trans 'Nothing open to star/unstar' %}",
                    type: 'warning',
                    icon: false,
                    sticker: false
                });
            }
        }

        function toggle_current_read_is_bookmarked() {

            if (open_content) {
                return toggle_is_bookmarked(open_content, {
                    done: "{% trans 'Marked for reading later.' %}",
                    undone: "{% trans 'Removed from reading list.' %}"
                });

            } else {
                notify({
                    text: "{% trans 'Nothing open to mark/unmark for later' %}",
                    type: 'warning',
                    icon: false,
                    sticker: false
                });
            }
        }

        // “Mark Read”, “Toggle Read”
        Mousetrap.bind(['m r', 't r'], function() {
            toggle_current_read_is_read();
            return false;
        });

        // “Mark Starred”, “Toggle Starred”
        Mousetrap.bind(['m s', 't s'], function() {
            toggle_current_read_is_starred();
            return false;
        });

        // “Star and go next”
        Mousetrap.bind(['shift+s'], function() {
            toggle_current_read_is_starred();
            open_next_read();
            return false;
        });

        // “Mark Bookmarked”, “Toggle Bookmarked”
        Mousetrap.bind(['m b', 'r l', 'm f l', 'k f l'], function() {
            toggle_current_read_is_bookmarked();
            return false;
        });

        // “mark for Later and go next”
        Mousetrap.bind(['shift+l'], function() {
            toggle_current_read_is_bookmarked();
            open_next_read();
            return false;
        });

    </script>
{% endblock extrajs_footer %}
